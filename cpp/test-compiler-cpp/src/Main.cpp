#include <iostream>
#include <string>

#include "Exception.h"
#include "errh/ErrorHandler.h"
#include "io/FileHandler.h"
#include "syntax/Lexer.h"
#include "semantic/Parser.h"
#include "semantic/Analyzer.h"
#include "generator/Generator.h"

void PrintException(const std::exception& e) {
	printf((string("EXCEPTION ") + e.what()).c_str());
}

void PrintException(const string& msg) {
	printf((string("EXCEPTION ") + msg).c_str());
}

void PrintMessages(const ErrorHandler& errh) {
	for (const auto& m : errh) {
		if (!m.IsAboutFile()) {
			printf("%s %s\n", ToString(m.severity).c_str(), m.text.c_str());
		}
		else if (!m.IsAboutLine()) {
			printf("%s %s %s\n", ToString(m.severity).c_str(), m.filepath.c_str(), m.text.c_str());
		}
		else if (!m.IsAboutPos()) {
			printf("%s %s:%d %s\n", ToString(m.severity).c_str(), m.filepath.c_str(),
				m.line, m.text.c_str());
		}
		else {
			printf("%s %s:%d,%d %s\n", ToString(m.severity).c_str(), m.filepath.c_str(),
				m.line, m.pos, m.text.c_str());
		}
	}
}

void AddBuiltinProcedure(SymbolTable& symbols, const string& identifier, const vector<string>& params) {
	auto proc = RefTo<AST::Procedure>();
	proc->identifier = identifier;
	for (const auto& paramIdent : params) {
		auto param = RefTo<AST::Declaration>();
		param->identifier = paramIdent;
		proc->parameters.emplace_back(param);
	}

	if (symbols.AddProc(proc)) {
		throw IncorrectImplException(__FILE__, __LINE__, "Builtin procedure '" + identifier + "' added multiple times");
	}
}

int main(int argc, char** argv) {
	try {
		ErrorHandler errh;

		if (argc != 2) {
			if (argc < 2)
				errh.PushErr("provide a filepath");
			if (argc > 2)
				errh.PushErr("too many args");

			PrintMessages(errh);
		}

		string path = argv[1];
		try {
			auto info = FileHandler::Read(path);
			printf("%s\n", info.content.c_str());

			// @improve: allow this to fail
			Lexer lexer = Lexer(info, &errh);
			errh.PushInfo("identified tokens", path);

			for (const auto& t : lexer.tokens) {
				printf("%s\n", t.ToString().c_str());
			}
			printf("\n");

			// create symbol table and fill in built-in symbols
			SymbolTable builtIns;
			AddBuiltinProcedure(builtIns, "print", { "num" });

			auto root = Parser(info, lexer, errh).BuildAST(&builtIns);
			if (!root) {
				errh.PushErr("failed to build AST", path);
			}
			else if (!root->IsType(AST::Type::Container)) {
				throw IncorrectImplException(__FILE__, __LINE__, "Parser::BuildAST(...) didn't return a container node");
			}
			else {
				errh.PushInfo("Built AST", path);
				printf("%s\n", root->ToString().c_str());

				auto cont = CastTo<AST::Container>(root);

				if (!Analyzer(errh).ValidateAST(cont)) {
					errh.PushErr("failed to validate AST", path);
				}
				else {
					errh.PushInfo("validated AST", path);
					string bytecode = CodeGenerator().Generate(cont);
					errh.PushInfo("generated bytecode", path);
					printf("%s\n", bytecode.c_str());

					string outPath = FileHandler::RemoveExtension(path) + ".vmc";
					FileHandler::Write(bytecode, outPath);
					errh.PushInfo("written file '" + outPath + "'", path);
				}
			}

			PrintMessages(errh);
		}
		catch (const FileAccessException& e) {
			PrintException(e);
		}
	}
	catch (const std::exception& e) {
		PrintException(e);
	}
	catch (const char* e) {
		PrintException(e);
	}
	catch (...) {
		PrintException("unknown error occured");
	}
}
